#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
#ifdef LINUX
#include <unistd.h>
#endif /* LINUX */

#define LUA_PROGNAME "ccpkg"

static const char *progname = LUA_PROGNAME;

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

/*
** Create the 'arg' table, which stores all arguments from the
** command line ('argv'). It should be aligned so that, at index 0,
** it has 'argv[script]', which is the script name. The arguments
** to the script (everything after 'script') go to positive indices;
** other arguments (before the script name) go to negative indices.
** If there is no script name, assume interpreter's name as base.
*/
static void createargtable (lua_State *L, char **argv, int argc) {
  int i, narg = argc - 1;
  lua_createtable(L, narg, 0);
  for (i = 1; i < argc; ++i) {
    lua_pushstring(L, argv[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}

static int pushcwd(lua_State *L)
{
  char cwd[4096];
  if (getcwd(cwd, sizeof(cwd)) != NULL) {
    lua_pushstring(L, cwd);
  } else {
    lua_pushstring(L, "");
  }
  return LUA_OK;
}

/* }================================================================== */


/*
** Main body of stand-alone interpreter (to be called in protected mode).
** Reads the options and handles them all.
*/
static int pmain (lua_State *L) {
  int argc = (int)lua_tointeger(L, 1);
  char **argv = (char **)lua_touserdata(L, 2);
  const char *ccpkg_root = getenv("CCPKG_ROOT");
  char script_path[1024], sep = '/';

  if (strchr(ccpkg_root, '\\') != NULL) {
    sep = '\\';
  }

  luaL_checkversion(L);  /* check that interpreter has correct version */
  luaL_openlibs(L);  /* open standard libraries */
  createargtable(L, argv, argc);  /* create table 'arg' */
  lua_gc(L, LUA_GCGEN, 0, 0);  /* GC in generational mode */

  snprintf(script_path, sizeof(script_path), "%s%cscripts%cmain.lua", ccpkg_root, sep, sep);

  if (luaL_dofile(L, script_path) != LUA_OK) {
    l_message(progname, lua_tostring(L, lua_gettop(L)));
    lua_pop(L, lua_gettop(L));
  }

  lua_pushboolean(L, 1);  /* signal no errors */
  return 1;
}

int main (int argc, char **argv) {
  int status, result;
  const char *ccpkg_root = getenv("CCPKG_ROOT");
  if (ccpkg_root == NULL) {
    l_message(progname, "please set $CCPKG_ROOT");
    return EXIT_FAILURE;
  }

  lua_State *L = luaL_newstate();  /* create state */
  if (L == NULL) {
    l_message(progname, "cannot create state: not enough memory");
    return EXIT_FAILURE;
  }

  /* create the ccpkg package */
  lua_newtable(L);

  /* ccpkg.root_dir */
  lua_pushstring(L, "root_dir");
  lua_pushstring(L, ccpkg_root);
  lua_settable(L, -3);

#ifdef LINUX
  lua_pushstring(L, "currrent_dir");
  pushcwd(L);
  lua_settable(L, -3);

  lua_pushstring(L, "host_system");
  lua_pushstring(L, "linux");
  lua_settable(L, -3);
#endif

  lua_setglobal(L, "ccpkg");

  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);  /* 1st argument */
  lua_pushlightuserdata(L, argv); /* 2nd argument */
  status = lua_pcall(L, 2, 1, 0);  /* do the call */
  result = lua_toboolean(L, -1);  /* get result */
  report(L, status);
  lua_close(L);
  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
}
